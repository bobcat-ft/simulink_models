-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\spike_generator_sim\redocking_site\redocking_site_cal_trel_k.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: redocking_site_cal_trel_k
-- Source Path: redocking_site/cal_trel_k
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.dataplane_pkg.ALL;

ENTITY redocking_site_cal_trel_k IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        synout                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        trel                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        trel_k                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END redocking_site_cal_trel_k;


ARCHITECTURE rtl OF redocking_site_cal_trel_k IS

  -- Component Declarations
  COMPONENT redocking_site_nfp_mul_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  COMPONENT redocking_site_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT redocking_site_nfp_div_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  COMPONENT redocking_site_nfp_relop_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out1                        :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : redocking_site_nfp_mul_single
    USE ENTITY work.redocking_site_nfp_mul_single(rtl);

  FOR ALL : redocking_site_SimpleDualPortRAM_generic
    USE ENTITY work.redocking_site_SimpleDualPortRAM_generic(rtl);

  FOR ALL : redocking_site_nfp_div_single
    USE ENTITY work.redocking_site_nfp_div_single(rtl);

  FOR ALL : redocking_site_nfp_relop_single
    USE ENTITY work.redocking_site_nfp_relop_single(rtl);

  -- Signals
  SIGNAL kconst                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL K_out1                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch_regin                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch_waddr                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL delayMatch_wrenb                 : std_logic;  -- ufix1
  SIGNAL delayMatch_raddr                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL delayMatch_regout                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL synout_1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Divide_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL reduced_regin                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL reduced_waddr                    : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL reduced_wrenb                    : std_logic;  -- ufix1
  SIGNAL reduced_raddr                    : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL reduced_regout                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL trel_1                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Min_stage1_sel                   : std_logic;
  SIGNAL delayMatch3_reg                  : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL delayMatch3_reg_next             : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL Divide_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL reduced_reg                      : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL reduced_reg_next                 : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL trel_2                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Min_stage1_val                   : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  -- Line 616
  -- This was taken out of the if statement since the value is only used 
  -- when the other 'variables' are recalculated so this will be ready

  u_nfp_mul_comp : redocking_site_nfp_mul_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => kconst,  -- ufix32
              nfp_in2 => trel,  -- ufix32
              nfp_out => K_out1  -- ufix32
              );

  u_ShiftRegisterRAM : redocking_site_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 3,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => delayMatch_regin,
              wr_addr => std_logic_vector(delayMatch_waddr),
              wr_en => delayMatch_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch_raddr),
              rd_dout => delayMatch_regout
              );

  u_nfp_div_comp : redocking_site_nfp_div_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => K_out1,  -- ufix32
              nfp_in2 => synout_1,  -- ufix32
              nfp_out => Divide_out1  -- ufix32
              );

  u_ShiftRegisterRAM_1 : redocking_site_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 6,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => reduced_regin,
              wr_addr => std_logic_vector(reduced_waddr),
              wr_en => reduced_wrenb,  -- ufix1
              rd_addr => std_logic_vector(reduced_raddr),
              rd_dout => reduced_regout
              );

  u_nfp_relop_comp : redocking_site_nfp_relop_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Divide_out1,  -- ufix32
              nfp_in2 => trel_1,  -- ufix32
              nfp_out1 => Min_stage1_sel
              );

  kconst <= X"42c80000";

  -- Input register for RAM-based shift register delayMatch
  delayMatch_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_regin <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch_regin <= synout;
      END IF;
    END IF;
  END PROCESS delayMatch_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 5
  -- 
  -- Write address counter for RAM-based shift register delayMatch
  delayMatch_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_waddr <= to_unsigned(16#0#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch_waddr >= to_unsigned(16#5#, 3) THEN 
          delayMatch_waddr <= to_unsigned(16#0#, 3);
        ELSE 
          delayMatch_waddr <= delayMatch_waddr + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch_wr_process;


  delayMatch_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 5
  -- 
  -- Read address counter for RAM-based shift register delayMatch
  delayMatch_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_raddr <= to_unsigned(16#1#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch_raddr >= to_unsigned(16#5#, 3) THEN 
          delayMatch_raddr <= to_unsigned(16#0#, 3);
        ELSE 
          delayMatch_raddr <= delayMatch_raddr + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch_rd_process;


  -- Output register for RAM-based shift register delayMatch
  delayMatch_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      synout_1 <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        synout_1 <= delayMatch_regout;
      END IF;
    END IF;
  END PROCESS delayMatch_regoutc_process;


  -- Input register for RAM-based shift register reduced
  reduced_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_regin <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        reduced_regin <= trel;
      END IF;
    END IF;
  END PROCESS reduced_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 37
  -- 
  -- Write address counter for RAM-based shift register reduced
  reduced_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_waddr <= to_unsigned(16#00#, 6);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF reduced_waddr >= to_unsigned(16#25#, 6) THEN 
          reduced_waddr <= to_unsigned(16#00#, 6);
        ELSE 
          reduced_waddr <= reduced_waddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS reduced_wr_process;


  reduced_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 37
  -- 
  -- Read address counter for RAM-based shift register reduced
  reduced_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_raddr <= to_unsigned(16#01#, 6);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF reduced_raddr >= to_unsigned(16#25#, 6) THEN 
          reduced_raddr <= to_unsigned(16#00#, 6);
        ELSE 
          reduced_raddr <= reduced_raddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS reduced_rd_process;


  -- Output register for RAM-based shift register reduced
  reduced_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      trel_1 <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        trel_1 <= reduced_regout;
      END IF;
    END IF;
  END PROCESS reduced_regoutc_process;


  delayMatch3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch3_reg(0) <= X"00000000";
      delayMatch3_reg(1) <= X"00000000";
      delayMatch3_reg(2) <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch3_reg(0) <= delayMatch3_reg_next(0);
        delayMatch3_reg(1) <= delayMatch3_reg_next(1);
        delayMatch3_reg(2) <= delayMatch3_reg_next(2);
      END IF;
    END IF;
  END PROCESS delayMatch3_process;

  Divide_out1_1 <= delayMatch3_reg(2);
  delayMatch3_reg_next(0) <= Divide_out1;
  delayMatch3_reg_next(1) <= delayMatch3_reg(0);
  delayMatch3_reg_next(2) <= delayMatch3_reg(1);

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_reg(0) <= X"00000000";
      reduced_reg(1) <= X"00000000";
      reduced_reg(2) <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        reduced_reg(0) <= reduced_reg_next(0);
        reduced_reg(1) <= reduced_reg_next(1);
        reduced_reg(2) <= reduced_reg_next(2);
      END IF;
    END IF;
  END PROCESS reduced_process;

  trel_2 <= reduced_reg(2);
  reduced_reg_next(0) <= trel_1;
  reduced_reg_next(1) <= reduced_reg(0);
  reduced_reg_next(2) <= reduced_reg(1);

  
  Min_stage1_val <= Divide_out1_1 WHEN Min_stage1_sel = '0' ELSE
      trel_2;

  trel_k <= Min_stage1_val;

END rtl;

