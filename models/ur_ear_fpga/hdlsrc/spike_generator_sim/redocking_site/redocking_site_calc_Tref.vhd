-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\spike_generator_sim\redocking_site\redocking_site_calc_Tref.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: redocking_site_calc_Tref
-- Source Path: redocking_site/calc_Tref
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY redocking_site_calc_Tref IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        trel_k                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        randData                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        tabs                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        Tref                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END redocking_site_calc_Tref;


ARCHITECTURE rtl OF redocking_site_calc_Tref IS

  -- Component Declarations
  COMPONENT redocking_site_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT redocking_site_nfp_log10_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  COMPONENT redocking_site_nfp_mul_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  COMPONENT redocking_site_nfp_sub_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : redocking_site_SimpleDualPortRAM_generic
    USE ENTITY work.redocking_site_SimpleDualPortRAM_generic(rtl);

  FOR ALL : redocking_site_nfp_log10_single
    USE ENTITY work.redocking_site_nfp_log10_single(rtl);

  FOR ALL : redocking_site_nfp_mul_single
    USE ENTITY work.redocking_site_nfp_mul_single(rtl);

  FOR ALL : redocking_site_nfp_sub_single
    USE ENTITY work.redocking_site_nfp_sub_single(rtl);

  -- Signals
  SIGNAL delayMatch1_regin                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch1_waddr                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL delayMatch1_wrenb                : std_logic;  -- ufix1
  SIGNAL delayMatch1_raddr                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL delayMatch1_regout               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL tabs_1                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch_regin                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch_waddr                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL delayMatch_wrenb                 : std_logic;  -- ufix1
  SIGNAL delayMatch_raddr                 : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL delayMatch_regout                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL trel_k_1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Log10_out1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Product_out1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Subtract_out1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  -- Line 618
  -- This was also taken out of the if statement since
  -- it is ready only when the 'variables' are recalculated

  u_ShiftRegisterRAM : redocking_site_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => delayMatch1_regin,
              wr_addr => std_logic_vector(delayMatch1_waddr),
              wr_en => delayMatch1_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch1_raddr),
              rd_dout => delayMatch1_regout
              );

  u_ShiftRegisterRAM_1 : redocking_site_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 4,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => delayMatch_regin,
              wr_addr => std_logic_vector(delayMatch_waddr),
              wr_en => delayMatch_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch_raddr),
              rd_dout => delayMatch_regout
              );

  u_nfp_log10_comp : redocking_site_nfp_log10_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => randData,  -- ufix32
              nfp_out => Log10_out1  -- ufix32
              );

  u_nfp_mul_comp : redocking_site_nfp_mul_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => trel_k_1,  -- ufix32
              nfp_in2 => Log10_out1,  -- ufix32
              nfp_out => Product_out1  -- ufix32
              );

  u_nfp_sub_comp : redocking_site_nfp_sub_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => tabs_1,  -- ufix32
              nfp_in2 => Product_out1,  -- ufix32
              nfp_out => Subtract_out1  -- ufix32
              );

  -- Input register for RAM-based shift register delayMatch1
  delayMatch1_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_regin <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch1_regin <= tabs;
      END IF;
    END IF;
  END PROCESS delayMatch1_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 21
  -- 
  -- Write address counter for RAM-based shift register delayMatch1
  delayMatch1_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_waddr <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch1_waddr >= to_unsigned(16#15#, 5) THEN 
          delayMatch1_waddr <= to_unsigned(16#00#, 5);
        ELSE 
          delayMatch1_waddr <= delayMatch1_waddr + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch1_wr_process;


  delayMatch1_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 21
  -- 
  -- Read address counter for RAM-based shift register delayMatch1
  delayMatch1_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_raddr <= to_unsigned(16#01#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch1_raddr >= to_unsigned(16#15#, 5) THEN 
          delayMatch1_raddr <= to_unsigned(16#00#, 5);
        ELSE 
          delayMatch1_raddr <= delayMatch1_raddr + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch1_rd_process;


  -- Output register for RAM-based shift register delayMatch1
  delayMatch1_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tabs_1 <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        tabs_1 <= delayMatch1_regout;
      END IF;
    END IF;
  END PROCESS delayMatch1_regoutc_process;


  -- Input register for RAM-based shift register delayMatch
  delayMatch_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_regin <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch_regin <= trel_k;
      END IF;
    END IF;
  END PROCESS delayMatch_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 13
  -- 
  -- Write address counter for RAM-based shift register delayMatch
  delayMatch_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_waddr <= to_unsigned(16#0#, 4);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch_waddr >= to_unsigned(16#D#, 4) THEN 
          delayMatch_waddr <= to_unsigned(16#0#, 4);
        ELSE 
          delayMatch_waddr <= delayMatch_waddr + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch_wr_process;


  delayMatch_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 13
  -- 
  -- Read address counter for RAM-based shift register delayMatch
  delayMatch_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_raddr <= to_unsigned(16#1#, 4);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch_raddr >= to_unsigned(16#D#, 4) THEN 
          delayMatch_raddr <= to_unsigned(16#0#, 4);
        ELSE 
          delayMatch_raddr <= delayMatch_raddr + to_unsigned(16#1#, 4);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch_rd_process;


  -- Output register for RAM-based shift register delayMatch
  delayMatch_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      trel_k_1 <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        trel_k_1 <= delayMatch_regout;
      END IF;
    END IF;
  END PROCESS delayMatch_regoutc_process;


  Tref <= Subtract_out1;

END rtl;

