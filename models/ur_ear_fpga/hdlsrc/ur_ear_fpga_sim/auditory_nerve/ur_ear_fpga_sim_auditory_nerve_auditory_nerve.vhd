-- -------------------------------------------------------------
-- 
-- File Name: D:\NIH3Repo\simulink_models\models\ur_ear_fpga\hdlsrc\ur_ear_fpga_sim\auditory_nerve\ur_ear_fpga_sim_auditory_nerve_auditory_nerve.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ur_ear_fpga_sim_auditory_nerve_auditory_nerve
-- Source Path: auditory_nerve
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ur_ear_fpga_sim_dataplane_pkg.ALL;

ENTITY ur_ear_fpga_sim_auditory_nerve_auditory_nerve IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_2048_0                      :   IN    std_logic;
        enb_1_2048_1                      :   IN    std_logic;
        auditory_nerve_in                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        auditory_nerve_out                :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END ur_ear_fpga_sim_auditory_nerve_auditory_nerve;


ARCHITECTURE rtl OF ur_ear_fpga_sim_auditory_nerve_auditory_nerve IS

  -- Component Declarations
  COMPONENT control_path
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          control_path_in                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          rsigma                          :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
          control_path_out                :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT filter_path
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          filter_path_in                  :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          rsigma                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          filter_path_out                 :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : control_path
    USE ENTITY work.ur_ear_fpga_sim_control_path_control_path(rtl);

  FOR ALL : filter_path
    USE ENTITY work.ur_ear_fpga_sim_filter_path_filter_path(rtl);

  -- Signals
  SIGNAL Control_Path_out1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Control_Path_out2                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Filter_Path_out1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay_reg                        : vector_of_std_logic_vector32(0 TO 30);  -- ufix32 [31]
  SIGNAL Delay_reg_next                   : vector_of_std_logic_vector32(0 TO 30);  -- ufix32 [31]
  SIGNAL Delay_out1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  -- model_IHC_BEZ2018.c: Line 363-379

  u_Control_Path : control_path
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2048_0 => enb_1_2048_0,
              control_path_in => auditory_nerve_in,  -- single
              rsigma => Control_Path_out1,  -- single
              control_path_out => Control_Path_out2  -- single
              );

  u_Filter_Path : filter_path
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_2048_1 => enb_1_2048_1,
              filter_path_in => Control_Path_out2,  -- single
              rsigma => Control_Path_out1,  -- single
              filter_path_out => Filter_Path_out1  -- single
              );

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_reg(0) <= X"00000000";
      Delay_reg(1) <= X"00000000";
      Delay_reg(2) <= X"00000000";
      Delay_reg(3) <= X"00000000";
      Delay_reg(4) <= X"00000000";
      Delay_reg(5) <= X"00000000";
      Delay_reg(6) <= X"00000000";
      Delay_reg(7) <= X"00000000";
      Delay_reg(8) <= X"00000000";
      Delay_reg(9) <= X"00000000";
      Delay_reg(10) <= X"00000000";
      Delay_reg(11) <= X"00000000";
      Delay_reg(12) <= X"00000000";
      Delay_reg(13) <= X"00000000";
      Delay_reg(14) <= X"00000000";
      Delay_reg(15) <= X"00000000";
      Delay_reg(16) <= X"00000000";
      Delay_reg(17) <= X"00000000";
      Delay_reg(18) <= X"00000000";
      Delay_reg(19) <= X"00000000";
      Delay_reg(20) <= X"00000000";
      Delay_reg(21) <= X"00000000";
      Delay_reg(22) <= X"00000000";
      Delay_reg(23) <= X"00000000";
      Delay_reg(24) <= X"00000000";
      Delay_reg(25) <= X"00000000";
      Delay_reg(26) <= X"00000000";
      Delay_reg(27) <= X"00000000";
      Delay_reg(28) <= X"00000000";
      Delay_reg(29) <= X"00000000";
      Delay_reg(30) <= X"00000000";
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_0 = '1' THEN
        Delay_reg(0) <= Delay_reg_next(0);
        Delay_reg(1) <= Delay_reg_next(1);
        Delay_reg(2) <= Delay_reg_next(2);
        Delay_reg(3) <= Delay_reg_next(3);
        Delay_reg(4) <= Delay_reg_next(4);
        Delay_reg(5) <= Delay_reg_next(5);
        Delay_reg(6) <= Delay_reg_next(6);
        Delay_reg(7) <= Delay_reg_next(7);
        Delay_reg(8) <= Delay_reg_next(8);
        Delay_reg(9) <= Delay_reg_next(9);
        Delay_reg(10) <= Delay_reg_next(10);
        Delay_reg(11) <= Delay_reg_next(11);
        Delay_reg(12) <= Delay_reg_next(12);
        Delay_reg(13) <= Delay_reg_next(13);
        Delay_reg(14) <= Delay_reg_next(14);
        Delay_reg(15) <= Delay_reg_next(15);
        Delay_reg(16) <= Delay_reg_next(16);
        Delay_reg(17) <= Delay_reg_next(17);
        Delay_reg(18) <= Delay_reg_next(18);
        Delay_reg(19) <= Delay_reg_next(19);
        Delay_reg(20) <= Delay_reg_next(20);
        Delay_reg(21) <= Delay_reg_next(21);
        Delay_reg(22) <= Delay_reg_next(22);
        Delay_reg(23) <= Delay_reg_next(23);
        Delay_reg(24) <= Delay_reg_next(24);
        Delay_reg(25) <= Delay_reg_next(25);
        Delay_reg(26) <= Delay_reg_next(26);
        Delay_reg(27) <= Delay_reg_next(27);
        Delay_reg(28) <= Delay_reg_next(28);
        Delay_reg(29) <= Delay_reg_next(29);
        Delay_reg(30) <= Delay_reg_next(30);
      END IF;
    END IF;
  END PROCESS Delay_process;

  Delay_out1 <= Delay_reg(30);
  Delay_reg_next(0) <= Filter_Path_out1;
  Delay_reg_next(1) <= Delay_reg(0);
  Delay_reg_next(2) <= Delay_reg(1);
  Delay_reg_next(3) <= Delay_reg(2);
  Delay_reg_next(4) <= Delay_reg(3);
  Delay_reg_next(5) <= Delay_reg(4);
  Delay_reg_next(6) <= Delay_reg(5);
  Delay_reg_next(7) <= Delay_reg(6);
  Delay_reg_next(8) <= Delay_reg(7);
  Delay_reg_next(9) <= Delay_reg(8);
  Delay_reg_next(10) <= Delay_reg(9);
  Delay_reg_next(11) <= Delay_reg(10);
  Delay_reg_next(12) <= Delay_reg(11);
  Delay_reg_next(13) <= Delay_reg(12);
  Delay_reg_next(14) <= Delay_reg(13);
  Delay_reg_next(15) <= Delay_reg(14);
  Delay_reg_next(16) <= Delay_reg(15);
  Delay_reg_next(17) <= Delay_reg(16);
  Delay_reg_next(18) <= Delay_reg(17);
  Delay_reg_next(19) <= Delay_reg(18);
  Delay_reg_next(20) <= Delay_reg(19);
  Delay_reg_next(21) <= Delay_reg(20);
  Delay_reg_next(22) <= Delay_reg(21);
  Delay_reg_next(23) <= Delay_reg(22);
  Delay_reg_next(24) <= Delay_reg(23);
  Delay_reg_next(25) <= Delay_reg(24);
  Delay_reg_next(26) <= Delay_reg(25);
  Delay_reg_next(27) <= Delay_reg(26);
  Delay_reg_next(28) <= Delay_reg(27);
  Delay_reg_next(29) <= Delay_reg(28);
  Delay_reg_next(30) <= Delay_reg(29);

  auditory_nerve_out <= Delay_out1;

END rtl;

