-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\DynamicCompressionModel\Linear_Approximation_block.vhd
-- Created: 2019-07-24 15:04:52
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Linear_Approximation_block
-- Source Path: DynamicCompressionModel/recalculate/Nchan_FbankAGC_AID/Compression_2/Compression_Gain_Calc/Linear_Approximation
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY Linear_Approximation_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        G_high                            :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        G_low                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        addr_low                          :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        alphaX_in                         :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        G_Desired                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En28
        );
END Linear_Approximation_block;


ARCHITECTURE rtl OF Linear_Approximation_block IS

  -- Component Declarations
  COMPONENT LSR_N_block
    PORT( NShifts                         :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          x_in                            :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          x_shifted                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En30
          );
  END COMPONENT;

  COMPONENT LSL_N_block1
    PORT( NShifts                         :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          x_in                            :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
          x_shifted                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : LSR_N_block
    USE ENTITY work.LSR_N_block(rtl);

  FOR ALL : LSL_N_block1
    USE ENTITY work.LSL_N_block1(rtl);

  -- Signals
  SIGNAL alphaX_in_signed                 : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL addr_low_unsigned                : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Bit_Slice_out1                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL NShifts                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL alpha2_NShifts                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL alpha2_NShifts_unsigned          : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL alpha2_M_bits_NShifts            : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL M                                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL M_2_M_bits_NShifts               : unsigned(36 DOWNTO 0);  -- ufix37_En30
  SIGNAL Subtract1_add_cast               : unsigned(37 DOWNTO 0);  -- ufix38_En30
  SIGNAL Subtract1_add_cast_1             : unsigned(37 DOWNTO 0);  -- ufix38_En30
  SIGNAL Subtract1_add_temp               : unsigned(37 DOWNTO 0);  -- ufix38_En30
  SIGNAL x_low                            : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Subtract2_out1                   : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL G_low_signed                     : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL G_high_signed                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Subtract_sub_cast                : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Subtract_sub_cast_1              : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Delta_G                          : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Constant2_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL alpha1_Delta_x                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL alpha1_Delta_x_unsigned          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Product2_cast                    : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Product2_mul_temp                : signed(65 DOWNTO 0);  -- sfix66_En28
  SIGNAL slope                            : signed(64 DOWNTO 0);  -- sfix65_En28
  SIGNAL M_2_2_NShifts                    : signed(96 DOWNTO 0);  -- sfix97_En56
  SIGNAL Data_Type_Conversion_out1        : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Subtract3_add_cast               : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Subtract3_add_cast_1             : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Subtract3_out1                   : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Data_Type_Conversion1_out1       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Switch_out1                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Unit_Delay_out1                  : signed(31 DOWNTO 0);  -- sfix32_En28

BEGIN
  -- Check if |X_in| is less than x_low,
  -- if true, use the low gain instead of
  -- linear interpolation
  -- 
  -- NOTE: When NShifts would be > 15, the output gain is slightly too small.
  -- This is marginal as this volume is below the threshold, but for consistency,
  -- all gains on volumes below the threshold will be set to x_low value, the 
  -- gain applied to an input of 2^-15
  -- Outputs above 85 dBA will be clipped to 85 dBA.

  u_LSR_N : LSR_N_block
    PORT MAP( NShifts => std_logic_vector(NShifts),  -- ufix4
              x_in => std_logic_vector(Constant_out1),  -- ufix32_En30
              x_shifted => alpha2_NShifts  -- ufix32_En30
              );

  u_LSL_N : LSL_N_block1
    PORT MAP( NShifts => std_logic_vector(NShifts),  -- ufix4
              x_in => std_logic_vector(Constant2_out1),  -- uint32
              x_shifted => alpha1_Delta_x  -- uint32
              );

  alphaX_in_signed <= signed(alphaX_in);

  addr_low_unsigned <= unsigned(addr_low);

  Bit_Slice_out1 <= addr_low_unsigned(8 DOWNTO 5);

  NShifts <=  NOT Bit_Slice_out1;

  Constant_out1 <= to_unsigned(1073741824, 32);

  alpha2_NShifts_unsigned <= unsigned(alpha2_NShifts);

  alpha2_M_bits_NShifts <= alpha2_NShifts_unsigned ror 5;

  M <= addr_low_unsigned(4 DOWNTO 0);

  M_2_M_bits_NShifts <= alpha2_M_bits_NShifts * M;

  Subtract1_add_cast <= resize(alpha2_NShifts_unsigned, 38);
  Subtract1_add_cast_1 <= resize(M_2_M_bits_NShifts, 38);
  Subtract1_add_temp <= Subtract1_add_cast + Subtract1_add_cast_1;
  x_low <= signed(Subtract1_add_temp(33 DOWNTO 2));

  Subtract2_out1 <= alphaX_in_signed - x_low;

  G_low_signed <= signed(G_low);

  G_high_signed <= signed(G_high);

  Subtract_sub_cast <= resize(G_high_signed, 33);
  Subtract_sub_cast_1 <= resize(G_low_signed, 33);
  Delta_G <= Subtract_sub_cast - Subtract_sub_cast_1;

  Constant2_out1 <= to_unsigned(32, 32);

  alpha1_Delta_x_unsigned <= unsigned(alpha1_Delta_x);

  Product2_cast <= signed(resize(alpha1_Delta_x_unsigned, 33));
  Product2_mul_temp <= Delta_G * Product2_cast;
  slope <= Product2_mul_temp(64 DOWNTO 0);

  M_2_2_NShifts <= slope * Subtract2_out1;

  Data_Type_Conversion_out1 <= M_2_2_NShifts(59 DOWNTO 28);

  
  Compare_To_Constant_out1 <= '1' WHEN Subtract2_out1 < to_signed(0, 32) ELSE
      '0';

  
  switch_compare_1 <= '1' WHEN Compare_To_Constant_out1 > '0' ELSE
      '0';

  Subtract3_add_cast <= resize(G_low_signed, 33);
  Subtract3_add_cast_1 <= resize(Data_Type_Conversion_out1, 33);
  Subtract3_out1 <= Subtract3_add_cast + Subtract3_add_cast_1;

  Data_Type_Conversion1_out1 <= Subtract3_out1(31 DOWNTO 0);

  
  Switch_out1 <= Data_Type_Conversion1_out1 WHEN switch_compare_1 = '0' ELSE
      G_low_signed;

  Unit_Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Unit_Delay_out1 <= to_signed(268435456, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Unit_Delay_out1 <= Switch_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_process;


  G_Desired <= std_logic_vector(Unit_Delay_out1);

END rtl;

