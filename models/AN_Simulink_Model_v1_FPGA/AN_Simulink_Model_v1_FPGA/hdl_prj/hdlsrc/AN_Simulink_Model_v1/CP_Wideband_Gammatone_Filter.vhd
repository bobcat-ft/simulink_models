-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\AN_Simulink_Model_v1\CP_Wideband_Gammatone_Filter.vhd
-- Created: 2020-04-16 16:05:25
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CP_Wideband_Gammatone_Filter
-- Source Path: AN_Simulink_Model_v1/Auditory Nerve Model/CP Wideband Gammatone Filter
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CP_Wideband_Gammatone_Filter IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        wbgain                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        tauwb                             :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        stimulus                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        output1                           :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END CP_Wideband_Gammatone_Filter;


ARCHITECTURE rtl OF CP_Wideband_Gammatone_Filter IS

  -- Component Declarations
  COMPONENT MATLAB_Function1
    PORT( phase                           :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          delta_phase                     :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          wbphase                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT nfp_add_single
    PORT( nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT nfp_sincos_single
    PORT( nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out1                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out2                        :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT nfp_mul_single
    PORT( nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT Third_Order_IIR_Filter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Signal_In_re                    :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          Signal_In_im                    :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          wbgain                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          tauwb                           :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          Signal_Out_re                   :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
          Signal_Out_im                   :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT nfp_uminus_single
    PORT( nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT nfp_sub_single
    PORT( nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT Calculate_wbout
    PORT( In1                             :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          In2                             :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          Out1                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : MATLAB_Function1
    USE ENTITY work.MATLAB_Function1(rtl);

  FOR ALL : nfp_add_single
    USE ENTITY work.nfp_add_single(rtl);

  FOR ALL : nfp_sincos_single
    USE ENTITY work.nfp_sincos_single(rtl);

  FOR ALL : nfp_mul_single
    USE ENTITY work.nfp_mul_single(rtl);

  FOR ALL : Third_Order_IIR_Filter
    USE ENTITY work.Third_Order_IIR_Filter(rtl);

  FOR ALL : nfp_uminus_single
    USE ENTITY work.nfp_uminus_single(rtl);

  FOR ALL : nfp_sub_single
    USE ENTITY work.nfp_sub_single(rtl);

  FOR ALL : Calculate_wbout
    USE ENTITY work.Calculate_wbout(rtl);

  -- Signals
  SIGNAL Constant_out1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL wbphase                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL wbphase_1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay_out1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL wbphase_2                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sin                              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL cos                              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Product_Re                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Product_Im                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL output_re                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL output_im                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Gain_out1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sin_1                            : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL cos_1                            : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Product1_Re_AC                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Product1_Re_BD                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mulOutput                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL wbout1                           : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  -- Passing Real Part and Terminating Imaginary Part
  -- 
  -- Note: Number of CORDIC iterations given by variable cordiciterationswb which is declared in the initialization 
  -- scrip
  -- 
  -- Adding delta_phase to itself after each iteration
  -- 
  -- MATLAB function to ensure the output remains within the CORDIC cos + jsin argument range of -2pi to 2pi
  -- 
  -- Control Path Wideband Gammatone Filter
  -- 
  -- Inputs: Phase-Shifted ME Filter Output
  -- 		Wideband Gain Feedback (wbgain)
  -- 		Wideband Time Constant Feedback 				(tauwb)
  -- 
  -- Output: Wideband Gammatone Filtered Signal 			 (wbout1)
  -- 
  -- - 3rd Order Wideband Gammatone IIR Filter
  -- 
  -- - Coefficients are determined in the subsystem and depend on gain and time constant feedback
  -- 
  -- - Implemented w/ Direct Form I Block Structure
  -- 
  -- Calculate Wideband Output
  -- 
  -- Inputs: Wideband Filter Output (wbout1)
  -- 		Wideband Time Constant Feedback 				(tauwb)
  -- 
  -- Output: Wideband Output  (wbout)
  -- 
  -- - A few simple calculations to get the wideband output

  u_MATLAB_Function1 : MATLAB_Function1
    PORT MAP( phase => Delay_out1,  -- single
              delta_phase => Constant_out1,  -- single
              wbphase => wbphase_2  -- single
              );

  u_nfp_add_comp : nfp_add_single
    PORT MAP( nfp_in1 => Constant_out1,  -- single
              nfp_in2 => wbphase_2,  -- single
              nfp_out => wbphase  -- single
              );

  u_nfp_sincos_comp : nfp_sincos_single
    PORT MAP( nfp_in => wbphase,  -- single
              nfp_out1 => sin,  -- single
              nfp_out2 => cos  -- single
              );

  u_nfp_mul_comp : nfp_mul_single
    PORT MAP( nfp_in1 => cos,  -- single
              nfp_in2 => stimulus,  -- single
              nfp_out => Product_Re  -- single
              );

  u_nfp_mul_comp_1 : nfp_mul_single
    PORT MAP( nfp_in1 => sin,  -- single
              nfp_in2 => stimulus,  -- single
              nfp_out => Product_Im  -- single
              );

  u_Third_Order_IIR_Filter : Third_Order_IIR_Filter
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              Signal_In_re => Product_Re,  -- single
              Signal_In_im => Product_Im,  -- single
              wbgain => wbgain,  -- single
              tauwb => tauwb,  -- single
              Signal_Out_re => output_re,  -- single
              Signal_Out_im => output_im  -- single
              );

  u_nfp_uminus_comp : nfp_uminus_single
    PORT MAP( nfp_in => wbphase,  -- single
              nfp_out => Gain_out1  -- single
              );

  u_nfp_sincos_comp_1 : nfp_sincos_single
    PORT MAP( nfp_in => Gain_out1,  -- single
              nfp_out1 => sin_1,  -- single
              nfp_out2 => cos_1  -- single
              );

  u_nfp_mul_comp_2 : nfp_mul_single
    PORT MAP( nfp_in1 => output_re,  -- single
              nfp_in2 => cos_1,  -- single
              nfp_out => Product1_Re_AC  -- single
              );

  u_nfp_mul_comp_3 : nfp_mul_single
    PORT MAP( nfp_in1 => output_im,  -- single
              nfp_in2 => sin_1,  -- single
              nfp_out => Product1_Re_BD  -- single
              );

  u_nfp_sub_comp : nfp_sub_single
    PORT MAP( nfp_in1 => Product1_Re_AC,  -- single
              nfp_in2 => Product1_Re_BD,  -- single
              nfp_out => mulOutput  -- single
              );

  u_Calculate_wbout : Calculate_wbout
    PORT MAP( In1 => wbout1,  -- single
              In2 => tauwb,  -- single
              Out1 => output1  -- single
              );

  Constant_out1 <= X"be2235a1";

  wbphase_1 <= wbphase;

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1 <= X"00000000";
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1 <= wbphase_1;
      END IF;
    END IF;
  END PROCESS Delay_process;


  wbout1 <= mulOutput;


END rtl;

